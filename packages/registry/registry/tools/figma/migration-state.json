{
	"name": "figma/migration-state",
	"type": "registry:tool",
	"title": "Migration State",
	"description": "Migration State tool for AI agents",
	"dependencies": ["ai@beta", "zod"],
	"files": [
		{
			"path": "tools/figma/migration-state.ts",
			"type": "registry:tool",
			"content": "import { promises as fs } from \"node:fs\"\nimport * as path from \"node:path\"\nimport { tool } from \"ai\"\nimport { z } from \"zod\"\nimport { getCachedFigmaData } from \"./fetch\"\nimport { getComponent } from \"./lib/parser\"\nimport type {\n\tComponentState,\n\tExtractedData,\n\tMigrationNextItem,\n\tMigrationPhase,\n\tMigrationProgressResult,\n\tMigrationState,\n\tMigrationStats,\n\tPageState,\n} from \"./lib/types\"\n\nconst MIGRATION_FILE = \".figma-migration.json\"\n\nasync function readMigrationState(cwd: string): Promise<MigrationState | null> {\n\ttry {\n\t\tconst filepath = path.join(cwd, MIGRATION_FILE)\n\t\tconst content = await fs.readFile(filepath, \"utf-8\")\n\t\treturn JSON.parse(content)\n\t} catch {\n\t\treturn null\n\t}\n}\n\nasync function writeMigrationState(\n\tcwd: string,\n\tstate: MigrationState,\n): Promise<void> {\n\tconst filepath = path.join(cwd, MIGRATION_FILE)\n\tstate.updatedAt = new Date().toISOString()\n\tawait fs.writeFile(filepath, JSON.stringify(state, null, 2))\n}\n\nfunction computeStats(state: MigrationState): MigrationStats {\n\tconst components = Object.values(state.components)\n\tconst pages = Object.values(state.pages)\n\n\tconst completedComponents = components.filter(\n\t\t(c) => c.status === \"done\",\n\t).length\n\tconst skippedComponents = components.filter(\n\t\t(c) => c.status === \"skipped\",\n\t).length\n\tconst completedPages = pages.filter((p) => p.status === \"done\").length\n\n\tconst allComponentsDone =\n\t\tcompletedComponents + skippedComponents === components.length\n\tconst allPagesDone = completedPages === pages.length\n\n\tlet phase: MigrationPhase = \"components\"\n\tif (allComponentsDone && !allPagesDone) {\n\t\tphase = \"pages\"\n\t} else if (allComponentsDone && allPagesDone) {\n\t\tphase = \"done\"\n\t}\n\n\treturn {\n\t\ttotalComponents: components.length,\n\t\tcompletedComponents,\n\t\tskippedComponents,\n\t\ttotalPages: pages.length,\n\t\tcompletedPages,\n\t\tphase,\n\t}\n}\n\nfunction updateDependencyReadiness(state: MigrationState): void {\n\tconst doneOrSkipped = new Set(\n\t\tObject.values(state.components)\n\t\t\t.filter((c) => c.status === \"done\" || c.status === \"skipped\")\n\t\t\t.map((c) => c.figmaId),\n\t)\n\n\tfor (const comp of Object.values(state.components)) {\n\t\tcomp.dependenciesReady =\n\t\t\tcomp.dependencies.length === 0 ||\n\t\t\tcomp.dependencies.every((dep) => doneOrSkipped.has(dep))\n\t}\n\n\tfor (const page of Object.values(state.pages)) {\n\t\tpage.componentsReady = page.componentsUsed.every((compId) =>\n\t\t\tdoneOrSkipped.has(compId),\n\t\t)\n\t\tif (page.status === \"blocked\" && page.componentsReady) {\n\t\t\tpage.status = \"pending\"\n\t\t}\n\t}\n}\n\nfunction buildComponentDependencies(\n\tdata: ExtractedData,\n): Map<string, Set<string>> {\n\tconst deps = new Map<string, Set<string>>()\n\n\tfor (const [compId, compData] of Object.entries(data.components)) {\n\t\tconst compDeps = new Set<string>()\n\n\t\tif (compData.definition?.children) {\n\t\t\tfindInstanceDependencies(compData.definition.children, compDeps, compId)\n\t\t}\n\n\t\tdeps.set(compId, compDeps)\n\t}\n\n\treturn deps\n}\n\nfunction findInstanceDependencies(\n\tnodes: ExtractedData[\"components\"][string][\"definition\"][],\n\tdeps: Set<string>,\n\tselfId: string,\n): void {\n\tfor (const node of nodes) {\n\t\tif (!node) continue\n\t\tif (\n\t\t\tnode.type === \"INSTANCE\" &&\n\t\t\tnode.componentId &&\n\t\t\tnode.componentId !== selfId\n\t\t) {\n\t\t\tdeps.add(node.componentId)\n\t\t}\n\t\tif (node.children) {\n\t\t\tfindInstanceDependencies(node.children, deps, selfId)\n\t\t}\n\t}\n}\n\nfunction createInitialState(\n\tdata: ExtractedData,\n\tfileKey: string,\n\tfileUrl: string,\n): MigrationState {\n\tconst componentDeps = buildComponentDependencies(data)\n\n\tconst components: Record<string, ComponentState> = {}\n\tfor (const [compId, compData] of Object.entries(data.components)) {\n\t\tconst deps = Array.from(componentDeps.get(compId) || [])\n\t\tcomponents[compId] = {\n\t\t\tfigmaId: compId,\n\t\t\tname: compData.name,\n\t\t\tstatus: \"pending\",\n\t\t\tdependencies: deps,\n\t\t\tdependenciesReady: deps.length === 0,\n\t\t\tinstanceCount: compData.instanceCount,\n\t\t}\n\t}\n\n\tconst pages: Record<string, PageState> = {}\n\tfor (const [frameId, frameData] of Object.entries(data.frames)) {\n\t\tpages[frameId] = {\n\t\t\tfigmaId: frameId,\n\t\t\tframeName: frameData.name,\n\t\t\tstatus: \"blocked\",\n\t\t\tcomponentsUsed: frameData.componentsUsed,\n\t\t\tcomponentsReady: false,\n\t\t}\n\t}\n\n\tconst state: MigrationState = {\n\t\tfigmaFileKey: fileKey,\n\t\tfigmaFileUrl: fileUrl,\n\t\tcreatedAt: new Date().toISOString(),\n\t\tupdatedAt: new Date().toISOString(),\n\t\tstats: {\n\t\t\ttotalComponents: Object.keys(components).length,\n\t\t\tcompletedComponents: 0,\n\t\t\tskippedComponents: 0,\n\t\t\ttotalPages: Object.keys(pages).length,\n\t\t\tcompletedPages: 0,\n\t\t\tphase: \"components\",\n\t\t},\n\t\tcomponents,\n\t\tpages,\n\t}\n\n\tupdateDependencyReadiness(state)\n\tstate.stats = computeStats(state)\n\n\treturn state\n}\n\n// ============================================================================\n// Tool: migrationInit\n// ============================================================================\n\nconst initDescription = `Initialize a Figma migration from the fetched Figma data.\n\nThis tool:\n1. Creates the migration state from the cached Figma data\n2. Analyzes component dependencies\n3. Creates .figma-migration.json in the working directory\n4. Returns a summary of what needs to be migrated\n\nPrerequisites:\n- Must call figmaFetch first to load the Figma file\n\nAfter initialization, use migrationNext to get items to work on.`\n\nexport const migrationInit = tool({\n\tdescription: initDescription,\n\tinputSchema: z.object({\n\t\tfileUrl: z\n\t\t\t.string()\n\t\t\t.optional()\n\t\t\t.describe(\"Optional: The original Figma URL for reference\"),\n\t}),\n\toutputSchema: z.union([\n\t\tz.object({\n\t\t\tstatus: z.literal(\"pending\"),\n\t\t\tmessage: z.string(),\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"success\"),\n\t\t\tmessage: z.string(),\n\t\t\tsummary: z.object({\n\t\t\t\ttotalComponents: z.number(),\n\t\t\t\ttotalPages: z.number(),\n\t\t\t\treadyComponents: z.number(),\n\t\t\t\ttopReadyComponents: z.array(z.string()),\n\t\t\t}),\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"error\"),\n\t\t\tmessage: z.string(),\n\t\t\terror: z.string(),\n\t\t}),\n\t]),\n\ttoModelOutput: (output) => {\n\t\tif (output.status === \"error\") {\n\t\t\treturn { type: \"error-text\", value: output.error }\n\t\t}\n\t\tif (output.status === \"pending\") {\n\t\t\treturn { type: \"text\", value: output.message }\n\t\t}\n\t\tconst { summary } = output\n\t\treturn {\n\t\t\ttype: \"text\",\n\t\t\tvalue: `Migration initialized!\n\nComponents: ${summary.totalComponents}\nPages: ${summary.totalPages}\nReady to start: ${summary.readyComponents} components\n\nTop components ready:\n${summary.topReadyComponents.map((n) => `  - ${n}`).join(\"\\n\")}\n\nUse migrationNext to get the next items to work on.`,\n\t\t}\n\t},\n\tasync *execute({ fileUrl }) {\n\t\tyield {\n\t\t\tstatus: \"pending\",\n\t\t\tmessage: \"Initializing migration...\",\n\t\t}\n\n\t\tconst data = getCachedFigmaData()\n\t\tif (!data) {\n\t\t\tyield {\n\t\t\t\tstatus: \"error\",\n\t\t\t\tmessage: \"No Figma data available\",\n\t\t\t\terror:\n\t\t\t\t\t\"No Figma data cached. Call figmaFetch first to load a Figma file.\",\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tconst cwd = process.cwd()\n\t\tconst existingState = await readMigrationState(cwd)\n\t\tif (existingState) {\n\t\t\tyield {\n\t\t\t\tstatus: \"error\",\n\t\t\t\tmessage: \"Migration already exists\",\n\t\t\t\terror: `A migration already exists for file ${existingState.figmaFileKey}. Delete .figma-migration.json to start fresh.`,\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tconst state = createInitialState(data, \"unknown\", fileUrl || \"\")\n\n\t\tawait writeMigrationState(cwd, state)\n\n\t\tconst readyComponents = Object.values(state.components)\n\t\t\t.filter((c) => c.status === \"pending\" && c.dependenciesReady)\n\t\t\t.sort((a, b) => b.instanceCount - a.instanceCount)\n\n\t\tyield {\n\t\t\tstatus: \"success\",\n\t\t\tmessage: \"Migration initialized\",\n\t\t\tsummary: {\n\t\t\t\ttotalComponents: state.stats.totalComponents,\n\t\t\t\ttotalPages: state.stats.totalPages,\n\t\t\t\treadyComponents: readyComponents.length,\n\t\t\t\ttopReadyComponents: readyComponents.slice(0, 5).map((c) => c.name),\n\t\t\t},\n\t\t}\n\t},\n})\n\n// ============================================================================\n// Tool: migrationProgress\n// ============================================================================\n\nconst progressDescription = `Get the current migration progress.\n\nReturns:\n- Current phase (components or pages)\n- Counts for completed, in-progress, and pending items\n- Current task being worked on (if any)\n- Next items that will be ready\n\nUse this to check overall progress without loading the full state.`\n\nexport const migrationProgress = tool({\n\tdescription: progressDescription,\n\tinputSchema: z.object({}),\n\toutputSchema: z.union([\n\t\tz.object({\n\t\t\tstatus: z.literal(\"pending\"),\n\t\t\tmessage: z.string(),\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"success\"),\n\t\t\tmessage: z.string(),\n\t\t\tprogress: z.object({\n\t\t\t\tphase: z.string(),\n\t\t\t\tcomponents: z.object({\n\t\t\t\t\ttotal: z.number(),\n\t\t\t\t\tdone: z.number(),\n\t\t\t\t\tinProgress: z.number(),\n\t\t\t\t\tpending: z.number(),\n\t\t\t\t\tskipped: z.number(),\n\t\t\t\t}),\n\t\t\t\tpages: z.object({\n\t\t\t\t\ttotal: z.number(),\n\t\t\t\t\tdone: z.number(),\n\t\t\t\t\tready: z.number(),\n\t\t\t\t\tblocked: z.number(),\n\t\t\t\t}),\n\t\t\t\tcurrentTask: z.string().optional(),\n\t\t\t\tnextUp: z.array(z.string()),\n\t\t\t}),\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"error\"),\n\t\t\tmessage: z.string(),\n\t\t\terror: z.string(),\n\t\t}),\n\t]),\n\ttoModelOutput: (output) => {\n\t\tif (output.status === \"error\") {\n\t\t\treturn { type: \"error-text\", value: output.error }\n\t\t}\n\t\tif (output.status === \"pending\") {\n\t\t\treturn { type: \"text\", value: output.message }\n\t\t}\n\t\tconst { progress } = output\n\t\tconst lines = [\n\t\t\t`Phase: ${progress.phase}`,\n\t\t\t\"\",\n\t\t\t\"Components:\",\n\t\t\t`  Done: ${progress.components.done}/${progress.components.total}`,\n\t\t\t`  In Progress: ${progress.components.inProgress}`,\n\t\t\t`  Pending: ${progress.components.pending}`,\n\t\t\t`  Skipped: ${progress.components.skipped}`,\n\t\t\t\"\",\n\t\t\t\"Pages:\",\n\t\t\t`  Done: ${progress.pages.done}/${progress.pages.total}`,\n\t\t\t`  Ready: ${progress.pages.ready}`,\n\t\t\t`  Blocked: ${progress.pages.blocked}`,\n\t\t]\n\t\tif (progress.currentTask) {\n\t\t\tlines.push(\"\", `Current: ${progress.currentTask}`)\n\t\t}\n\t\tif (progress.nextUp.length > 0) {\n\t\t\tlines.push(\"\", `Next up: ${progress.nextUp.join(\", \")}`)\n\t\t}\n\t\treturn { type: \"text\", value: lines.join(\"\\n\") }\n\t},\n\tasync *execute() {\n\t\tyield {\n\t\t\tstatus: \"pending\",\n\t\t\tmessage: \"Reading migration progress...\",\n\t\t}\n\n\t\tconst cwd = process.cwd()\n\t\tconst state = await readMigrationState(cwd)\n\n\t\tif (!state) {\n\t\t\tyield {\n\t\t\t\tstatus: \"error\",\n\t\t\t\tmessage: \"No migration found\",\n\t\t\t\terror: \"No migration state found. Call migrationInit first.\",\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tconst components = Object.values(state.components)\n\t\tconst pages = Object.values(state.pages)\n\n\t\tconst inProgress = components.find((c) => c.status === \"in_progress\")\n\t\tconst inProgressPage = pages.find((p) => p.status === \"in_progress\")\n\n\t\tconst readyComponents = components\n\t\t\t.filter((c) => c.status === \"pending\" && c.dependenciesReady)\n\t\t\t.sort((a, b) => b.instanceCount - a.instanceCount)\n\n\t\tconst readyPages = pages.filter(\n\t\t\t(p) => p.status === \"pending\" && p.componentsReady,\n\t\t)\n\n\t\tlet nextUp: string[] = []\n\t\tif (state.stats.phase === \"components\") {\n\t\t\tnextUp = readyComponents.slice(0, 3).map((c) => c.name)\n\t\t} else if (state.stats.phase === \"pages\") {\n\t\t\tnextUp = readyPages.slice(0, 3).map((p) => p.frameName)\n\t\t}\n\n\t\tconst progress: MigrationProgressResult = {\n\t\t\tphase: state.stats.phase,\n\t\t\tcomponents: {\n\t\t\t\ttotal: components.length,\n\t\t\t\tdone: components.filter((c) => c.status === \"done\").length,\n\t\t\t\tinProgress: components.filter((c) => c.status === \"in_progress\").length,\n\t\t\t\tpending: components.filter((c) => c.status === \"pending\").length,\n\t\t\t\tskipped: components.filter((c) => c.status === \"skipped\").length,\n\t\t\t},\n\t\t\tpages: {\n\t\t\t\ttotal: pages.length,\n\t\t\t\tdone: pages.filter((p) => p.status === \"done\").length,\n\t\t\t\tready: readyPages.length,\n\t\t\t\tblocked: pages.filter((p) => p.status === \"blocked\").length,\n\t\t\t},\n\t\t\tcurrentTask: inProgress?.name || inProgressPage?.frameName,\n\t\t\tnextUp,\n\t\t}\n\n\t\tyield {\n\t\t\tstatus: \"success\",\n\t\t\tmessage: \"Progress retrieved\",\n\t\t\tprogress,\n\t\t}\n\t},\n})\n\n// ============================================================================\n// Tool: migrationNext\n// ============================================================================\n\nconst nextDescription = `Get the next items ready to be migrated.\n\nReturns items that:\n- For components: Have all dependencies completed\n- For pages: Have all required components completed\n\nItems are sorted by priority (instance count for components).\n\nUse this to decide what to work on next.`\n\nexport const migrationNext = tool({\n\tdescription: nextDescription,\n\tinputSchema: z.object({\n\t\tlimit: z.number().default(5).describe(\"Maximum number of items to return\"),\n\t\ttype: z\n\t\t\t.enum([\"component\", \"page\", \"any\"])\n\t\t\t.default(\"any\")\n\t\t\t.describe(\"Filter by item type\"),\n\t}),\n\toutputSchema: z.union([\n\t\tz.object({\n\t\t\tstatus: z.literal(\"pending\"),\n\t\t\tmessage: z.string(),\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"success\"),\n\t\t\tmessage: z.string(),\n\t\t\tphase: z.string(),\n\t\t\titems: z.array(\n\t\t\t\tz.object({\n\t\t\t\t\ttype: z.enum([\"component\", \"page\"]),\n\t\t\t\t\tid: z.string(),\n\t\t\t\t\tname: z.string(),\n\t\t\t\t\tinstanceCount: z.number().optional(),\n\t\t\t\t\tdependencies: z.array(z.string()).optional(),\n\t\t\t\t\tcomponentsUsed: z.array(z.string()).optional(),\n\t\t\t\t}),\n\t\t\t),\n\t\t\tremaining: z.number(),\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"error\"),\n\t\t\tmessage: z.string(),\n\t\t\terror: z.string(),\n\t\t}),\n\t]),\n\ttoModelOutput: (output) => {\n\t\tif (output.status === \"error\") {\n\t\t\treturn { type: \"error-text\", value: output.error }\n\t\t}\n\t\tif (output.status === \"pending\") {\n\t\t\treturn { type: \"text\", value: output.message }\n\t\t}\n\t\tif (output.items.length === 0) {\n\t\t\treturn {\n\t\t\t\ttype: \"text\",\n\t\t\t\tvalue:\n\t\t\t\t\toutput.phase === \"done\"\n\t\t\t\t\t\t? \"Migration complete! All items have been processed.\"\n\t\t\t\t\t\t: \"No items ready. Some items may be blocked by dependencies.\",\n\t\t\t}\n\t\t}\n\t\tconst lines = output.items.map((item) => {\n\t\t\tif (item.type === \"component\") {\n\t\t\t\tconst deps = item.dependencies?.length\n\t\t\t\t\t? ` (deps: ${item.dependencies.length})`\n\t\t\t\t\t: \"\"\n\t\t\t\treturn `- [component] ${item.name} (${item.instanceCount}x)${deps}`\n\t\t\t}\n\t\t\treturn `- [page] ${item.name} (${item.componentsUsed?.length || 0} components)`\n\t\t})\n\t\tlines.push(\"\", `${output.remaining} more items remaining`)\n\t\treturn { type: \"text\", value: lines.join(\"\\n\") }\n\t},\n\tasync *execute({ limit, type }) {\n\t\tyield {\n\t\t\tstatus: \"pending\",\n\t\t\tmessage: \"Finding next items...\",\n\t\t}\n\n\t\tconst cwd = process.cwd()\n\t\tconst state = await readMigrationState(cwd)\n\n\t\tif (!state) {\n\t\t\tyield {\n\t\t\t\tstatus: \"error\",\n\t\t\t\tmessage: \"No migration found\",\n\t\t\t\terror: \"No migration state found. Call migrationInit first.\",\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tconst items: MigrationNextItem[] = []\n\n\t\tif (type === \"any\" || type === \"component\") {\n\t\t\tconst readyComponents = Object.values(state.components)\n\t\t\t\t.filter((c) => c.status === \"pending\" && c.dependenciesReady)\n\t\t\t\t.sort((a, b) => b.instanceCount - a.instanceCount)\n\n\t\t\tfor (const comp of readyComponents) {\n\t\t\t\titems.push({\n\t\t\t\t\ttype: \"component\",\n\t\t\t\t\tid: comp.figmaId,\n\t\t\t\t\tname: comp.name,\n\t\t\t\t\tinstanceCount: comp.instanceCount,\n\t\t\t\t\tdependencies: comp.dependencies,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tif ((type === \"any\" && state.stats.phase === \"pages\") || type === \"page\") {\n\t\t\tconst readyPages = Object.values(state.pages).filter(\n\t\t\t\t(p) => p.status === \"pending\" && p.componentsReady,\n\t\t\t)\n\n\t\t\tfor (const page of readyPages) {\n\t\t\t\titems.push({\n\t\t\t\t\ttype: \"page\",\n\t\t\t\t\tid: page.figmaId,\n\t\t\t\t\tname: page.frameName,\n\t\t\t\t\tcomponentsUsed: page.componentsUsed,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tconst remaining = items.length - limit\n\t\tconst limited = items.slice(0, limit)\n\n\t\tyield {\n\t\t\tstatus: \"success\",\n\t\t\tmessage: `Found ${items.length} ready items`,\n\t\t\tphase: state.stats.phase,\n\t\t\titems: limited,\n\t\t\tremaining: Math.max(0, remaining),\n\t\t}\n\t},\n})\n\n// ============================================================================\n// Tool: migrationStart\n// ============================================================================\n\nconst startDescription = `Start working on a migration item.\n\nThis tool:\n1. Marks the item as in_progress\n2. Returns the full Figma definition needed to implement it\n3. Suggests an output path\n\nOnly one item should be in_progress at a time.\n\nAfter implementing, call migrationComplete to mark it done.`\n\nexport const migrationStart = tool({\n\tdescription: startDescription,\n\tinputSchema: z.object({\n\t\tid: z.string().describe(\"The component or page ID to start working on\"),\n\t}),\n\toutputSchema: z.union([\n\t\tz.object({\n\t\t\tstatus: z.literal(\"pending\"),\n\t\t\tmessage: z.string(),\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"success\"),\n\t\t\tmessage: z.string(),\n\t\t\ttype: z.enum([\"component\", \"page\"]),\n\t\t\tid: z.string(),\n\t\t\tname: z.string(),\n\t\t\tdefinition: z.any(),\n\t\t\tsuggestedPath: z.string(),\n\t\t\tdependencies: z.array(z.string()).optional(),\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"error\"),\n\t\t\tmessage: z.string(),\n\t\t\terror: z.string(),\n\t\t}),\n\t]),\n\ttoModelOutput: (output) => {\n\t\tif (output.status === \"error\") {\n\t\t\treturn { type: \"error-text\", value: output.error }\n\t\t}\n\t\tif (output.status === \"pending\") {\n\t\t\treturn { type: \"text\", value: output.message }\n\t\t}\n\t\treturn {\n\t\t\ttype: \"text\",\n\t\t\tvalue: `Started working on ${output.type}: ${output.name}\n\nSuggested path: ${output.suggestedPath}\n${output.dependencies?.length ? `Dependencies: ${output.dependencies.join(\", \")}` : \"\"}\n\nDefinition provided. Implement the ${output.type} and call migrationComplete when done.`,\n\t\t}\n\t},\n\tasync *execute({ id }) {\n\t\tyield {\n\t\t\tstatus: \"pending\",\n\t\t\tmessage: `Starting work on ${id}...`,\n\t\t}\n\n\t\tconst cwd = process.cwd()\n\t\tconst state = await readMigrationState(cwd)\n\n\t\tif (!state) {\n\t\t\tyield {\n\t\t\t\tstatus: \"error\",\n\t\t\t\tmessage: \"No migration found\",\n\t\t\t\terror: \"No migration state found. Call migrationInit first.\",\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tconst data = getCachedFigmaData()\n\t\tif (!data) {\n\t\t\tyield {\n\t\t\t\tstatus: \"error\",\n\t\t\t\tmessage: \"No Figma data\",\n\t\t\t\terror: \"Figma data not cached. Call figmaFetch first.\",\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tconst component = state.components[id]\n\t\tif (component) {\n\t\t\tif (component.status === \"done\" || component.status === \"skipped\") {\n\t\t\t\tyield {\n\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\tmessage: \"Already processed\",\n\t\t\t\t\terror: `Component ${component.name} is already ${component.status}.`,\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (!component.dependenciesReady) {\n\t\t\t\tyield {\n\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\tmessage: \"Dependencies not ready\",\n\t\t\t\t\terror: `Component ${component.name} has unfinished dependencies: ${component.dependencies.join(\", \")}`,\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tcomponent.status = \"in_progress\"\n\t\t\tawait writeMigrationState(cwd, state)\n\n\t\t\tconst compData = getComponent(data, id)\n\t\t\tconst safeName = component.name.replace(/[^a-zA-Z0-9]/g, \"\")\n\n\t\t\tyield {\n\t\t\t\tstatus: \"success\",\n\t\t\t\tmessage: `Started component: ${component.name}`,\n\t\t\t\ttype: \"component\",\n\t\t\t\tid,\n\t\t\t\tname: component.name,\n\t\t\t\tdefinition: compData?.definition || null,\n\t\t\t\tsuggestedPath: `src/components/${safeName}.tsx`,\n\t\t\t\tdependencies: component.dependencies,\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tconst page = state.pages[id]\n\t\tif (page) {\n\t\t\tif (page.status === \"done\") {\n\t\t\t\tyield {\n\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\tmessage: \"Already processed\",\n\t\t\t\t\terror: `Page ${page.frameName} is already done.`,\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (!page.componentsReady) {\n\t\t\t\tyield {\n\t\t\t\t\tstatus: \"error\",\n\t\t\t\t\tmessage: \"Components not ready\",\n\t\t\t\t\terror: `Page ${page.frameName} has unfinished components.`,\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tpage.status = \"in_progress\"\n\t\t\tawait writeMigrationState(cwd, state)\n\n\t\t\tconst frame = data.frames[id]\n\t\t\tconst safeName = page.frameName\n\t\t\t\t.toLowerCase()\n\t\t\t\t.replace(/[^a-z0-9]+/g, \"-\")\n\t\t\t\t.replace(/^-|-$/g, \"\")\n\n\t\t\tyield {\n\t\t\t\tstatus: \"success\",\n\t\t\t\tmessage: `Started page: ${page.frameName}`,\n\t\t\t\ttype: \"page\",\n\t\t\t\tid,\n\t\t\t\tname: page.frameName,\n\t\t\t\tdefinition: frame || null,\n\t\t\t\tsuggestedPath: `src/app/${safeName}/page.tsx`,\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tyield {\n\t\t\tstatus: \"error\",\n\t\t\tmessage: \"Item not found\",\n\t\t\terror: `No component or page found with ID: ${id}`,\n\t\t}\n\t},\n})\n\n// ============================================================================\n// Tool: migrationComplete\n// ============================================================================\n\nconst completeDescription = `Mark a migration item as complete.\n\nThis tool:\n1. Marks the item as done\n2. Records the output path\n3. Updates dependency status for other items\n4. Returns newly unlocked items\n\nCall this after successfully implementing a component or page.`\n\nexport const migrationComplete = tool({\n\tdescription: completeDescription,\n\tinputSchema: z.object({\n\t\tid: z.string().describe(\"The component or page ID that was completed\"),\n\t\toutputPath: z.string().describe(\"The file path where the item was written\"),\n\t}),\n\toutputSchema: z.union([\n\t\tz.object({\n\t\t\tstatus: z.literal(\"pending\"),\n\t\t\tmessage: z.string(),\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"success\"),\n\t\t\tmessage: z.string(),\n\t\t\tcompleted: z.string(),\n\t\t\tnewReady: z.array(z.string()),\n\t\t\tprogress: z.object({\n\t\t\t\tdone: z.number(),\n\t\t\t\ttotal: z.number(),\n\t\t\t}),\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"error\"),\n\t\t\tmessage: z.string(),\n\t\t\terror: z.string(),\n\t\t}),\n\t]),\n\ttoModelOutput: (output) => {\n\t\tif (output.status === \"error\") {\n\t\t\treturn { type: \"error-text\", value: output.error }\n\t\t}\n\t\tif (output.status === \"pending\") {\n\t\t\treturn { type: \"text\", value: output.message }\n\t\t}\n\t\tconst lines = [\n\t\t\t`Completed: ${output.completed}`,\n\t\t\t`Progress: ${output.progress.done}/${output.progress.total}`,\n\t\t]\n\t\tif (output.newReady.length > 0) {\n\t\t\tlines.push(`Newly ready: ${output.newReady.join(\", \")}`)\n\t\t}\n\t\treturn { type: \"text\", value: lines.join(\"\\n\") }\n\t},\n\tasync *execute({ id, outputPath }) {\n\t\tyield {\n\t\t\tstatus: \"pending\",\n\t\t\tmessage: `Marking ${id} as complete...`,\n\t\t}\n\n\t\tconst cwd = process.cwd()\n\t\tconst state = await readMigrationState(cwd)\n\n\t\tif (!state) {\n\t\t\tyield {\n\t\t\t\tstatus: \"error\",\n\t\t\t\tmessage: \"No migration found\",\n\t\t\t\terror: \"No migration state found.\",\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tconst component = state.components[id]\n\t\tif (component) {\n\t\t\tconst wasNotReady = Object.values(state.components)\n\t\t\t\t.filter((c) => c.status === \"pending\" && !c.dependenciesReady)\n\t\t\t\t.map((c) => c.figmaId)\n\n\t\t\tcomponent.status = \"done\"\n\t\t\tcomponent.outputPath = outputPath\n\t\t\tcomponent.completedAt = new Date().toISOString()\n\n\t\t\tupdateDependencyReadiness(state)\n\t\t\tstate.stats = computeStats(state)\n\t\t\tawait writeMigrationState(cwd, state)\n\n\t\t\tconst newlyReady = Object.values(state.components)\n\t\t\t\t.filter(\n\t\t\t\t\t(c) =>\n\t\t\t\t\t\tc.status === \"pending\" &&\n\t\t\t\t\t\tc.dependenciesReady &&\n\t\t\t\t\t\twasNotReady.includes(c.figmaId),\n\t\t\t\t)\n\t\t\t\t.map((c) => c.name)\n\n\t\t\tyield {\n\t\t\t\tstatus: \"success\",\n\t\t\t\tmessage: `Completed component: ${component.name}`,\n\t\t\t\tcompleted: component.name,\n\t\t\t\tnewReady: newlyReady,\n\t\t\t\tprogress: {\n\t\t\t\t\tdone: state.stats.completedComponents,\n\t\t\t\t\ttotal: state.stats.totalComponents,\n\t\t\t\t},\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tconst page = state.pages[id]\n\t\tif (page) {\n\t\t\tpage.status = \"done\"\n\t\t\tpage.outputPath = outputPath\n\t\t\tpage.completedAt = new Date().toISOString()\n\n\t\t\tstate.stats = computeStats(state)\n\t\t\tawait writeMigrationState(cwd, state)\n\n\t\t\tyield {\n\t\t\t\tstatus: \"success\",\n\t\t\t\tmessage: `Completed page: ${page.frameName}`,\n\t\t\t\tcompleted: page.frameName,\n\t\t\t\tnewReady: [],\n\t\t\t\tprogress: {\n\t\t\t\t\tdone: state.stats.completedPages,\n\t\t\t\t\ttotal: state.stats.totalPages,\n\t\t\t\t},\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tyield {\n\t\t\tstatus: \"error\",\n\t\t\tmessage: \"Item not found\",\n\t\t\terror: `No component or page found with ID: ${id}`,\n\t\t}\n\t},\n})\n\n// ============================================================================\n// Tool: migrationSkip\n// ============================================================================\n\nconst skipDescription = `Skip a migration item.\n\nUse this for:\n- External components (from a library)\n- Components that already exist\n- Items that don't need migration\n\nSkipped items are treated as \"done\" for dependency purposes.`\n\nexport const migrationSkip = tool({\n\tdescription: skipDescription,\n\tinputSchema: z.object({\n\t\tid: z.string().describe(\"The component or page ID to skip\"),\n\t\treason: z\n\t\t\t.string()\n\t\t\t.describe(\"Reason for skipping (e.g., 'external component')\"),\n\t}),\n\toutputSchema: z.union([\n\t\tz.object({\n\t\t\tstatus: z.literal(\"pending\"),\n\t\t\tmessage: z.string(),\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"success\"),\n\t\t\tmessage: z.string(),\n\t\t\tskipped: z.string(),\n\t\t\treason: z.string(),\n\t\t\tnewReady: z.array(z.string()),\n\t\t}),\n\t\tz.object({\n\t\t\tstatus: z.literal(\"error\"),\n\t\t\tmessage: z.string(),\n\t\t\terror: z.string(),\n\t\t}),\n\t]),\n\ttoModelOutput: (output) => {\n\t\tif (output.status === \"error\") {\n\t\t\treturn { type: \"error-text\", value: output.error }\n\t\t}\n\t\tif (output.status === \"pending\") {\n\t\t\treturn { type: \"text\", value: output.message }\n\t\t}\n\t\tconst lines = [`Skipped: ${output.skipped}`, `Reason: ${output.reason}`]\n\t\tif (output.newReady.length > 0) {\n\t\t\tlines.push(`Newly ready: ${output.newReady.join(\", \")}`)\n\t\t}\n\t\treturn { type: \"text\", value: lines.join(\"\\n\") }\n\t},\n\tasync *execute({ id, reason }) {\n\t\tyield {\n\t\t\tstatus: \"pending\",\n\t\t\tmessage: `Skipping ${id}...`,\n\t\t}\n\n\t\tconst cwd = process.cwd()\n\t\tconst state = await readMigrationState(cwd)\n\n\t\tif (!state) {\n\t\t\tyield {\n\t\t\t\tstatus: \"error\",\n\t\t\t\tmessage: \"No migration found\",\n\t\t\t\terror: \"No migration state found.\",\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tconst component = state.components[id]\n\t\tif (component) {\n\t\t\tconst wasNotReady = Object.values(state.components)\n\t\t\t\t.filter((c) => c.status === \"pending\" && !c.dependenciesReady)\n\t\t\t\t.map((c) => c.figmaId)\n\n\t\t\tcomponent.status = \"skipped\"\n\t\t\tcomponent.skipReason = reason\n\t\t\tcomponent.completedAt = new Date().toISOString()\n\n\t\t\tupdateDependencyReadiness(state)\n\t\t\tstate.stats = computeStats(state)\n\t\t\tawait writeMigrationState(cwd, state)\n\n\t\t\tconst newlyReady = Object.values(state.components)\n\t\t\t\t.filter(\n\t\t\t\t\t(c) =>\n\t\t\t\t\t\tc.status === \"pending\" &&\n\t\t\t\t\t\tc.dependenciesReady &&\n\t\t\t\t\t\twasNotReady.includes(c.figmaId),\n\t\t\t\t)\n\t\t\t\t.map((c) => c.name)\n\n\t\t\tyield {\n\t\t\t\tstatus: \"success\",\n\t\t\t\tmessage: `Skipped component: ${component.name}`,\n\t\t\t\tskipped: component.name,\n\t\t\t\treason,\n\t\t\t\tnewReady: newlyReady,\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tconst page = state.pages[id]\n\t\tif (page) {\n\t\t\tyield {\n\t\t\t\tstatus: \"error\",\n\t\t\t\tmessage: \"Cannot skip pages\",\n\t\t\t\terror: \"Pages cannot be skipped, only components.\",\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tyield {\n\t\t\tstatus: \"error\",\n\t\t\tmessage: \"Item not found\",\n\t\t\terror: `No component found with ID: ${id}`,\n\t\t}\n\t},\n})\n"
		},
		{
			"path": "tools/figma/lib/parser.ts",
			"type": "registry:lib",
			"content": "import type {\n\tComponentData,\n\tExtractedData,\n\tExtractionConfig,\n\tFigmaFile,\n\tFigmaNode,\n\tFrameInfo,\n\tPageInfo,\n\tSectionInfo,\n} from \"./types\"\n\nconst defaultConfig: Required<ExtractionConfig> = {\n\tskipInvisible: true,\n}\n\ninterface TraversalContext {\n\tpageId: string\n\tframeId: string\n}\n\nfunction isFrameType(type: string): boolean {\n\treturn type === \"FRAME\" || type === \"COMPONENT\" || type === \"COMPONENT_SET\"\n}\n\nexport function extractFigmaStructure(\n\tfileData: FigmaFile,\n\tconfig: ExtractionConfig = {},\n): ExtractedData {\n\tconst { skipInvisible } = { ...defaultConfig, ...config }\n\n\tconst shouldSkipNode = (node: FigmaNode): boolean => {\n\t\tif (skipInvisible && node.visible === false) {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\tconst filterInvisibleNodes = (node: FigmaNode): FigmaNode => {\n\t\tif (!skipInvisible) return node\n\n\t\tconst filtered = { ...node }\n\t\tif (filtered.children) {\n\t\t\tfiltered.children = filtered.children\n\t\t\t\t.filter((child) => child.visible !== false)\n\t\t\t\t.map((child) => filterInvisibleNodes(child))\n\t\t}\n\t\treturn filtered\n\t}\n\n\tconst componentUsage = new Map<\n\t\tstring,\n\t\t{\n\t\t\tusedInFrames: Set<string>\n\t\t\tinstanceCount: number\n\t\t}\n\t>()\n\n\tconst pages: PageInfo[] = []\n\tconst allSections = new Map<string, SectionInfo>()\n\tconst allFrames = new Map<string, FrameInfo>()\n\tconst componentDefinitions = new Map<string, FigmaNode>()\n\tconst frameComponents = new Map<string, Set<string>>()\n\n\tconst getComponentName = (id: string): string => {\n\t\treturn fileData.components[id]?.name || \"Unknown Component\"\n\t}\n\n\tconst getComponentDescription = (id: string): string | undefined => {\n\t\treturn fileData.components[id]?.description\n\t}\n\n\tconst cloneNode = (node: FigmaNode): FigmaNode => {\n\t\treturn JSON.parse(JSON.stringify(node))\n\t}\n\n\tfunction collectSections(\n\t\tnode: FigmaNode,\n\t\tparentSectionId?: string,\n\t): string[] {\n\t\tconst sectionIds: string[] = []\n\n\t\tif (!node.children) return sectionIds\n\n\t\tfor (const child of node.children) {\n\t\t\tif (shouldSkipNode(child)) continue\n\n\t\t\tif (child.type === \"SECTION\") {\n\t\t\t\tconst sectionInfo: SectionInfo = {\n\t\t\t\t\tid: child.id,\n\t\t\t\t\tname: child.name,\n\t\t\t\t\tparentSectionId,\n\t\t\t\t\tframeIds: [],\n\t\t\t\t}\n\n\t\t\t\tif (child.children) {\n\t\t\t\t\tfor (const grandChild of child.children) {\n\t\t\t\t\t\tif (!shouldSkipNode(grandChild) && isFrameType(grandChild.type)) {\n\t\t\t\t\t\t\tsectionInfo.frameIds.push(grandChild.id)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tallSections.set(child.id, sectionInfo)\n\t\t\t\tsectionIds.push(child.id)\n\n\t\t\t\tconst nestedSectionIds = collectSections(child, child.id)\n\t\t\t\tsectionIds.push(...nestedSectionIds)\n\t\t\t}\n\t\t}\n\n\t\treturn sectionIds\n\t}\n\n\tfunction traverseFrame(node: FigmaNode, context: TraversalContext) {\n\t\tif (shouldSkipNode(node)) return\n\n\t\tif (node.type === \"COMPONENT\") {\n\t\t\tcomponentDefinitions.set(node.id, filterInvisibleNodes(cloneNode(node)))\n\t\t}\n\n\t\tif (node.type === \"COMPONENT_SET\") {\n\t\t\tcomponentDefinitions.set(node.id, filterInvisibleNodes(cloneNode(node)))\n\t\t\tif (node.children) {\n\t\t\t\tfor (const variant of node.children) {\n\t\t\t\t\tif (variant.type === \"COMPONENT\" && !shouldSkipNode(variant)) {\n\t\t\t\t\t\tcomponentDefinitions.set(\n\t\t\t\t\t\t\tvariant.id,\n\t\t\t\t\t\t\tfilterInvisibleNodes(cloneNode(variant)),\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (node.type === \"INSTANCE\" && node.componentId) {\n\t\t\tconst compId = node.componentId\n\n\t\t\tframeComponents.get(context.frameId)?.add(compId)\n\n\t\t\tconst existing = componentUsage.get(compId)\n\t\t\tif (existing) {\n\t\t\t\texisting.instanceCount++\n\t\t\t\texisting.usedInFrames.add(context.frameId)\n\t\t\t} else {\n\t\t\t\tcomponentUsage.set(compId, {\n\t\t\t\t\tinstanceCount: 1,\n\t\t\t\t\tusedInFrames: new Set([context.frameId]),\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tif (node.children) {\n\t\t\tfor (const child of node.children) {\n\t\t\t\ttraverseFrame(child, context)\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction collectFrames(\n\t\tnode: FigmaNode,\n\t\tpageId: string,\n\t\tsectionId?: string,\n\t): FrameInfo[] {\n\t\tconst frames: FrameInfo[] = []\n\n\t\tif (!node.children) return frames\n\n\t\tfor (const child of node.children) {\n\t\t\tif (shouldSkipNode(child)) continue\n\n\t\t\tif (child.type === \"SECTION\") {\n\t\t\t\tconst sectionFrames = collectFrames(child, pageId, child.id)\n\t\t\t\tframes.push(...sectionFrames)\n\t\t\t} else if (isFrameType(child.type)) {\n\t\t\t\tconst frameInfo: FrameInfo = {\n\t\t\t\t\tid: child.id,\n\t\t\t\t\tname: child.name,\n\t\t\t\t\ttype: child.type,\n\t\t\t\t\tpageId,\n\t\t\t\t\tsectionId,\n\t\t\t\t\tcomponentsUsed: [],\n\t\t\t\t}\n\n\t\t\t\tframeComponents.set(child.id, new Set())\n\n\t\t\t\ttraverseFrame(child, {\n\t\t\t\t\tpageId,\n\t\t\t\t\tframeId: child.id,\n\t\t\t\t})\n\n\t\t\t\tframeInfo.componentsUsed = Array.from(\n\t\t\t\t\tframeComponents.get(child.id) || [],\n\t\t\t\t)\n\n\t\t\t\tframes.push(frameInfo)\n\t\t\t\tallFrames.set(child.id, frameInfo)\n\t\t\t}\n\t\t}\n\n\t\treturn frames\n\t}\n\n\tif (fileData.document.children) {\n\t\tfor (const pageNode of fileData.document.children) {\n\t\t\tif (pageNode.type === \"CANVAS\") {\n\t\t\t\tconst pageId = pageNode.id\n\t\t\t\tconst pageName = pageNode.name\n\n\t\t\t\tconst sectionIds = collectSections(pageNode)\n\t\t\t\tconst frames = collectFrames(pageNode, pageId)\n\n\t\t\t\tpages.push({\n\t\t\t\t\tid: pageId,\n\t\t\t\t\tname: pageName,\n\t\t\t\t\tsectionIds,\n\t\t\t\t\tframeIds: frames.map((f) => f.id),\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tconst components: Record<string, ComponentData> = {}\n\n\tfor (const [compId, usage] of componentUsage.entries()) {\n\t\tcomponents[compId] = {\n\t\t\tname: getComponentName(compId),\n\t\t\tdescription: getComponentDescription(compId),\n\t\t\tdefinition: componentDefinitions.get(compId) || null,\n\t\t\tusedInFrames: Array.from(usage.usedInFrames),\n\t\t\tinstanceCount: usage.instanceCount,\n\t\t}\n\t}\n\n\treturn {\n\t\tpages,\n\t\tsections: Object.fromEntries(allSections),\n\t\tframes: Object.fromEntries(allFrames),\n\t\tcomponents,\n\t}\n}\n\nexport function getComponent(\n\tdata: ExtractedData,\n\tnameOrId: string,\n): ComponentData | null {\n\tif (data.components[nameOrId]) {\n\t\treturn data.components[nameOrId]\n\t}\n\n\tconst lowerName = nameOrId.toLowerCase()\n\tfor (const comp of Object.values(data.components)) {\n\t\tif (comp.name.toLowerCase() === lowerName) {\n\t\t\treturn comp\n\t\t}\n\t}\n\n\treturn null\n}\n\nexport function listComponents(\n\tdata: ExtractedData,\n): { id: string; name: string; instanceCount: number }[] {\n\treturn Object.entries(data.components)\n\t\t.map(([id, comp]) => ({\n\t\t\tid,\n\t\t\tname: comp.name,\n\t\t\tinstanceCount: comp.instanceCount,\n\t\t}))\n\t\t.sort((a, b) => b.instanceCount - a.instanceCount)\n}\n\nexport function listFrames(data: ExtractedData): FrameInfo[] {\n\treturn Object.values(data.frames)\n}\n\nexport function getFrame(\n\tdata: ExtractedData,\n\tnameOrId: string,\n): FrameInfo | null {\n\tif (data.frames[nameOrId]) {\n\t\treturn data.frames[nameOrId]\n\t}\n\n\tconst lowerName = nameOrId.toLowerCase()\n\tfor (const frame of Object.values(data.frames)) {\n\t\tif (frame.name.toLowerCase() === lowerName) {\n\t\t\treturn frame\n\t\t}\n\t}\n\n\treturn null\n}\n"
		},
		{
			"path": "tools/figma/lib/types.ts",
			"type": "registry:lib",
			"content": "// ============================================================================\n// Figma Node Types & Interfaces\n// Based on https://developers.figma.com/docs/rest-api/file-node-types/\n// ============================================================================\n\nexport interface Color {\n\tr: number\n\tg: number\n\tb: number\n\ta: number\n}\n\nexport interface Paint {\n\ttype:\n\t\t| \"SOLID\"\n\t\t| \"GRADIENT_LINEAR\"\n\t\t| \"GRADIENT_RADIAL\"\n\t\t| \"GRADIENT_ANGULAR\"\n\t\t| \"GRADIENT_DIAMOND\"\n\t\t| \"IMAGE\"\n\t\t| \"EMOJI\"\n\t\t| \"VIDEO\"\n\tvisible?: boolean\n\topacity?: number\n\tcolor?: Color\n\tblendMode?: string\n\tgradientHandlePositions?: { x: number; y: number }[]\n\tgradientStops?: { position: number; color: Color }[]\n\tscaleMode?: string\n\timageRef?: string\n}\n\nexport interface Effect {\n\ttype: \"INNER_SHADOW\" | \"DROP_SHADOW\" | \"LAYER_BLUR\" | \"BACKGROUND_BLUR\"\n\tvisible?: boolean\n\tradius: number\n\tcolor?: Color\n\tblendMode?: string\n\toffset?: { x: number; y: number }\n\tspread?: number\n}\n\nexport interface Constraint {\n\ttype: \"MIN\" | \"CENTER\" | \"MAX\" | \"STRETCH\" | \"SCALE\"\n\tvalue: number\n}\n\nexport interface Rectangle {\n\tx: number\n\ty: number\n\twidth: number\n\theight: number\n}\n\nexport interface TypeStyle {\n\tfontFamily?: string\n\tfontPostScriptName?: string\n\tfontWeight?: number\n\tfontSize?: number\n\ttextAlignHorizontal?: \"LEFT\" | \"RIGHT\" | \"CENTER\" | \"JUSTIFIED\"\n\ttextAlignVertical?: \"TOP\" | \"CENTER\" | \"BOTTOM\"\n\tletterSpacing?: number\n\tlineHeightPx?: number\n\tlineHeightPercent?: number\n\tlineHeightUnit?: string\n\ttextCase?: \"ORIGINAL\" | \"UPPER\" | \"LOWER\" | \"TITLE\"\n\ttextDecoration?: \"NONE\" | \"STRIKETHROUGH\" | \"UNDERLINE\"\n\tfills?: Paint[]\n}\n\nexport interface StrokeWeights {\n\ttop: number\n\tright: number\n\tbottom: number\n\tleft: number\n}\n\nexport interface FigmaNode {\n\tid: string\n\tname: string\n\ttype: string\n\tvisible?: boolean\n\tchildren?: FigmaNode[]\n\n\t// Instance-specific\n\tcomponentId?: string\n\n\t// Component-specific\n\tcomponentPropertyDefinitions?: Record<string, unknown>\n\n\t// Geometry\n\tabsoluteBoundingBox?: Rectangle\n\tabsoluteRenderBounds?: Rectangle\n\tsize?: { x: number; y: number }\n\trelativeTransform?: number[][]\n\n\t// Constraints & Layout\n\tconstraints?: { horizontal: string; vertical: string }\n\tlayoutAlign?: string\n\tlayoutGrow?: number\n\tlayoutPositioning?: string\n\n\t// Auto Layout (Flexbox)\n\tlayoutMode?: \"NONE\" | \"HORIZONTAL\" | \"VERTICAL\"\n\tprimaryAxisSizingMode?: \"FIXED\" | \"AUTO\"\n\tcounterAxisSizingMode?: \"FIXED\" | \"AUTO\"\n\tprimaryAxisAlignItems?: \"MIN\" | \"CENTER\" | \"MAX\" | \"SPACE_BETWEEN\"\n\tcounterAxisAlignItems?: \"MIN\" | \"CENTER\" | \"MAX\" | \"BASELINE\"\n\tpaddingLeft?: number\n\tpaddingRight?: number\n\tpaddingTop?: number\n\tpaddingBottom?: number\n\titemSpacing?: number\n\tcounterAxisSpacing?: number\n\tlayoutWrap?: \"NO_WRAP\" | \"WRAP\"\n\n\t// Appearance\n\tfills?: Paint[]\n\tstrokes?: Paint[]\n\tstrokeWeight?: number\n\tstrokeAlign?: \"INSIDE\" | \"OUTSIDE\" | \"CENTER\"\n\tstrokeCap?: string\n\tstrokeJoin?: string\n\tstrokeDashes?: number[]\n\tindividualStrokeWeights?: StrokeWeights\n\tcornerRadius?: number\n\trectangleCornerRadii?: number[]\n\teffects?: Effect[]\n\tblendMode?: string\n\topacity?: number\n\tisMask?: boolean\n\n\t// Clipping\n\tclipsContent?: boolean\n\n\t// Text-specific\n\tcharacters?: string\n\tstyle?: TypeStyle\n\tcharacterStyleOverrides?: number[]\n\tstyleOverrideTable?: Record<string, TypeStyle>\n\ttextAutoResize?: string\n\n\t// Vector-specific\n\tfillGeometry?: unknown[]\n\tstrokeGeometry?: unknown[]\n\n\t// Export settings\n\texportSettings?: unknown[]\n\n\t// Interactions/Prototyping\n\ttransitionNodeID?: string\n\ttransitionDuration?: number\n\ttransitionEasing?: string\n}\n\nexport interface FigmaFile {\n\tdocument: FigmaNode\n\tcomponents: Record<\n\t\tstring,\n\t\t{ name: string; description?: string; key?: string }\n\t>\n\tstyles?: Record<\n\t\tstring,\n\t\t{ name: string; styleType: string; description?: string }\n\t>\n}\n\n// ============================================================================\n// Extracted Data Types\n// ============================================================================\n\nexport interface FrameInfo {\n\tid: string\n\tname: string\n\ttype: string\n\tpageId: string\n\tsectionId?: string\n\tcomponentsUsed: string[]\n}\n\nexport interface SectionInfo {\n\tid: string\n\tname: string\n\tparentSectionId?: string\n\tframeIds: string[]\n}\n\nexport interface PageInfo {\n\tid: string\n\tname: string\n\tsectionIds: string[]\n\tframeIds: string[]\n}\n\nexport interface ComponentData {\n\tname: string\n\tdescription?: string\n\tdefinition: FigmaNode | null\n\tusedInFrames: string[]\n\tinstanceCount: number\n}\n\nexport interface ExtractedData {\n\tpages: PageInfo[]\n\tsections: Record<string, SectionInfo>\n\tframes: Record<string, FrameInfo>\n\tcomponents: Record<string, ComponentData>\n}\n\nexport interface ExtractionConfig {\n\tskipInvisible?: boolean\n}\n\n// ============================================================================\n// Migration State Types\n// ============================================================================\n\nexport type MigrationPhase = \"components\" | \"pages\" | \"done\"\n\nexport type ComponentStatus = \"pending\" | \"in_progress\" | \"done\" | \"skipped\"\n\nexport type PageStatus = \"blocked\" | \"pending\" | \"in_progress\" | \"done\"\n\nexport interface ComponentState {\n\tfigmaId: string\n\tname: string\n\tstatus: ComponentStatus\n\tdependencies: string[]\n\tdependenciesReady: boolean\n\tinstanceCount: number\n\toutputPath?: string\n\tcompletedAt?: string\n\tskipReason?: string\n}\n\nexport interface PageState {\n\tfigmaId: string\n\tframeName: string\n\tstatus: PageStatus\n\tcomponentsUsed: string[]\n\tcomponentsReady: boolean\n\toutputPath?: string\n\tcompletedAt?: string\n}\n\nexport interface MigrationStats {\n\ttotalComponents: number\n\tcompletedComponents: number\n\tskippedComponents: number\n\ttotalPages: number\n\tcompletedPages: number\n\tphase: MigrationPhase\n}\n\nexport interface MigrationState {\n\tfigmaFileKey: string\n\tfigmaFileUrl: string\n\tcreatedAt: string\n\tupdatedAt: string\n\tstats: MigrationStats\n\tcomponents: Record<string, ComponentState>\n\tpages: Record<string, PageState>\n}\n\n// ============================================================================\n// Tool Input/Output Types\n// ============================================================================\n\nexport interface MigrationNextItem {\n\ttype: \"component\" | \"page\"\n\tid: string\n\tname: string\n\tinstanceCount?: number\n\tdependencies?: string[]\n\tcomponentsUsed?: string[]\n}\n\nexport interface MigrationProgressResult {\n\tphase: MigrationPhase\n\tcomponents: {\n\t\ttotal: number\n\t\tdone: number\n\t\tinProgress: number\n\t\tpending: number\n\t\tskipped: number\n\t}\n\tpages: {\n\t\ttotal: number\n\t\tdone: number\n\t\tready: number\n\t\tblocked: number\n\t}\n\tcurrentTask?: string\n\tnextUp: string[]\n}\n"
		}
	]
}
