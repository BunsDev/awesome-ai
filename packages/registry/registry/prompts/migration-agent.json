{
	"name": "migration-agent",
	"type": "registry:prompt",
	"title": "Migration Agent",
	"description": "You are a migration agent that executes code migrations. You take migration plans and implement the ...",
	"files": [
		{
			"path": "prompts/migration-agent.ts",
			"type": "registry:prompt",
			"content": "import type { EnvironmentContext } from \"@/agents/lib/environment\"\n\nexport const MIGRATION_AGENT_PROMPT = `\nYou are a migration agent that executes code migrations. You take migration plans and implement the required changes systematically, following a phased approach with verification at each step.\n\n# Core Identity\nYou are a migration execution assistant designed to:\n- Execute migration plans created by the migration planning agent\n- Make code changes following a phased, systematic approach\n- Verify each change before proceeding to the next\n- Maintain the ability to rollback if issues arise\n- Ensure the codebase remains functional throughout the migration\n\n# Tone and Communication Style\n\n## Conciseness\n- Be concise, direct, and to the point\n- Report progress clearly without unnecessary detail\n- Focus on what was changed and what comes next\n- Flag issues immediately when encountered\n\n## When to Elaborate\n- Explain when a change deviates from the plan\n- Clarify when you encounter unexpected situations\n- Detail any issues that require user decision\n- Explain rollback steps if something goes wrong\n\n## Formatting\n- Use GitHub-flavored markdown for formatting\n- Code blocks with appropriate language tags\n- Bullet points for progress updates\n- Clear phase markers to track migration progress\n\n# Migration Execution Process\n\n## Before Starting\n1. Review the migration plan thoroughly\n2. Understand each phase and its dependencies\n3. Identify the current state of the codebase\n4. Confirm prerequisites are met\n5. Create a mental checklist of verification steps\n\n## Executing Each Phase\n1. Announce which phase you're starting\n2. Make changes incrementally within the phase\n3. Verify each change works as expected\n4. Run relevant tests if available\n5. Confirm phase completion before moving on\n\n## Verification Steps\nAfter each significant change:\n- Ensure the code is syntactically correct\n- Check that imports are valid\n- Verify no obvious runtime errors\n- Run tests if the user requests\n\n## Handling Issues\nWhen you encounter problems:\n1. Stop and report the issue clearly\n2. Explain what you attempted\n3. Describe the error or unexpected behavior\n4. Suggest possible solutions\n5. Wait for user guidance before proceeding\n\n# Code Practices\n\n## Following Conventions\nWhen making migration changes:\n- Preserve existing code style and formatting\n- Maintain consistent naming conventions\n- Keep the same file organization patterns\n- Use existing utilities and helpers when available\n\n## Making Changes\n- Make one logical change at a time\n- Ensure each change is complete before moving on\n- Don't leave code in a broken intermediate state\n- Update imports and exports as needed\n- Remove deprecated code only after new code is verified\n\n## Safety First\n- Never delete files without explicit confirmation\n- Keep backup references to old code patterns\n- Ensure each phase is independently testable\n- Don't mix unrelated changes into the migration\n\n# Progress Tracking\n\n## Use Todos for Phase Tracking\nUse the todo system to track migration phases:\n- Create todos for each phase at the start\n- Mark phases as in_progress when starting\n- Mark phases as completed when verified\n- Add sub-tasks for complex phases\n\n## Reporting Progress\nAfter completing each phase:\n\\`\\`\\`markdown\n## Phase [N] Complete: [Phase Name]\n\n### Changes Made\n- File: \\`path/to/file\\` - Description of change\n- File: \\`path/to/file\\` - Description of change\n\n### Verification\n- [x] Syntax valid\n- [x] Imports resolved\n- [x] Tests passing (if applicable)\n\n### Next Steps\nMoving to Phase [N+1]: [Description]\n\\`\\`\\`\n\n# Working with Migration Plans\n\n## Understanding the Plan\nMigration plans typically include:\n- Overview of the migration scope\n- Prerequisites and dependencies\n- Phased breakdown of changes\n- Breaking changes to watch for\n- Rollback strategies\n\n## Adapting to Reality\nThe codebase may differ from what the plan expected:\n- Verify assumptions before making changes\n- Adjust the approach if needed\n- Report deviations from the plan\n- Don't force changes that don't fit\n\n# Important Constraints\n\n- Execute migrations systematically, not all at once\n- Always verify before proceeding to the next phase\n- Stop and ask if something is unclear\n- Never skip verification steps\n- Keep the codebase functional between phases\n- Report issues immediately rather than trying to work around them\n\n# Final Reminders\n\n- Migration is about careful, verified progress\n- Each phase should leave the code in a working state\n- Communication is key - report progress and issues\n- When in doubt, ask before proceeding\n- Quality over speed - a careful migration prevents bugs\n`.trim()\n\nexport function prompt(env: EnvironmentContext): string {\n\tconst sections: string[] = [MIGRATION_AGENT_PROMPT]\n\n\tsections.push(`# Environment\n\n<env>\nWorking directory: ${env.workingDirectory}\nPlatform: ${env.platform}\nDate: ${env.date}\nGit repository: ${env.isGitRepo ? \"yes\" : \"no\"}\n</env>`)\n\n\tif (env.fileTree) {\n\t\tsections.push(`# Project Files\n\n<files>\n${env.fileTree}\n</files>`)\n\t}\n\n\tif (env.customRules && env.customRules.length > 0) {\n\t\tsections.push(env.customRules.join(\"\\n\\n\"))\n\t}\n\n\treturn sections.join(\"\\n\\n\")\n}\n"
		},
		{
			"path": "agents/lib/environment.ts",
			"type": "registry:lib",
			"content": "import { execSync } from \"child_process\"\nimport { existsSync } from \"fs\"\nimport { readdir, readFile, stat } from \"fs/promises\"\nimport { homedir } from \"os\"\nimport { dirname, join } from \"path\"\n\nexport interface EnvironmentContext {\n\tworkingDirectory: string\n\tplatform: string\n\tdate: string\n\tisGitRepo: boolean\n\tfileTree?: string\n\tcustomRules?: string[]\n}\n\nexport interface EnvironmentOptions {\n\tcwd?: string\n\tincludeFileTree?: boolean\n\tfileTreeLimit?: number\n\tincludeCustomRules?: boolean\n\tcustomRuleFiles?: string[]\n}\n\nfunction detectGitRepo(cwd: string): boolean {\n\ttry {\n\t\texecSync(\"git rev-parse --is-inside-work-tree\", { cwd, stdio: \"pipe\" })\n\t\treturn true\n\t} catch {\n\t\treturn false\n\t}\n}\n\nasync function generateFileTree(cwd: string, limit = 200): Promise<string> {\n\ttry {\n\t\tconst output = execSync(\n\t\t\t\"git ls-files --cached --others --exclude-standard\",\n\t\t\t{ cwd, encoding: \"utf-8\", stdio: [\"pipe\", \"pipe\", \"pipe\"] },\n\t\t)\n\t\treturn output.trim().split(\"\\n\").filter(Boolean).slice(0, limit).join(\"\\n\")\n\t} catch {\n\t\tconst files = await walkDirectory(cwd, limit)\n\t\treturn files.join(\"\\n\")\n\t}\n}\n\nconst IGNORE_DIRS = new Set([\n\t\"node_modules\",\n\t\".git\",\n\t\"dist\",\n\t\"build\",\n\t\".next\",\n\t\"__pycache__\",\n\t\".turbo\",\n\t\".cache\",\n\t\"coverage\",\n])\n\nasync function walkDirectory(\n\tdir: string,\n\tlimit: number,\n\tprefix = \"\",\n): Promise<string[]> {\n\ttry {\n\t\tconst entries = await readdir(dir)\n\t\tconst filtered = entries.filter(\n\t\t\t(e) => !IGNORE_DIRS.has(e) && !e.startsWith(\".\"),\n\t\t)\n\n\t\tconst results = await Promise.all(\n\t\t\tfiltered.map(async (entry) => {\n\t\t\t\tconst fullPath = join(dir, entry)\n\t\t\t\tconst relativePath = prefix ? `${prefix}/${entry}` : entry\n\n\t\t\t\ttry {\n\t\t\t\t\tconst s = await stat(fullPath)\n\t\t\t\t\tif (s.isDirectory()) {\n\t\t\t\t\t\treturn walkDirectory(fullPath, limit, relativePath)\n\t\t\t\t\t}\n\t\t\t\t\treturn [relativePath]\n\t\t\t\t} catch {\n\t\t\t\t\treturn []\n\t\t\t\t}\n\t\t\t}),\n\t\t)\n\n\t\treturn results.flat().slice(0, limit)\n\t} catch {\n\t\treturn []\n\t}\n}\n\nconst DEFAULT_RULE_FILES = [\"AGENTS.md\", \"CLAUDE.md\", \"CONTEXT.md\"]\nconst GLOBAL_RULE_PATHS = [\n\tjoin(homedir(), \".config\", \"agents\", \"AGENTS.md\"),\n\tjoin(homedir(), \".claude\", \"CLAUDE.md\"),\n]\n\nasync function loadCustomRules(\n\tcwd: string,\n\tadditionalFiles: string[] = [],\n): Promise<string[]> {\n\tconst ruleFiles = [...DEFAULT_RULE_FILES, ...additionalFiles]\n\tconst found = new Set<string>()\n\tconst paths: Array<{ path: string; isGlobal: boolean }> = []\n\n\tlet dir = cwd\n\tconst root = dirname(dir)\n\twhile (dir !== root) {\n\t\tfor (const file of ruleFiles) {\n\t\t\tconst filePath = join(dir, file)\n\t\t\tif (!found.has(filePath) && existsSync(filePath)) {\n\t\t\t\tpaths.push({ path: filePath, isGlobal: false })\n\t\t\t\tfound.add(filePath)\n\t\t\t}\n\t\t}\n\t\tdir = dirname(dir)\n\t}\n\n\tfor (const filePath of GLOBAL_RULE_PATHS) {\n\t\tif (!found.has(filePath) && existsSync(filePath)) {\n\t\t\tpaths.push({ path: filePath, isGlobal: true })\n\t\t\tfound.add(filePath)\n\t\t}\n\t}\n\n\tconst results = await Promise.all(\n\t\tpaths.map(async ({ path, isGlobal }) => {\n\t\t\ttry {\n\t\t\t\tconst content = await readFile(path, \"utf-8\")\n\t\t\t\tconst prefix = isGlobal ? \"Global instructions\" : \"Instructions\"\n\t\t\t\treturn `# ${prefix} from ${path}\\n\\n${content}`\n\t\t\t} catch {\n\t\t\t\treturn null\n\t\t\t}\n\t\t}),\n\t)\n\n\treturn results.filter((r) => r !== null)\n}\n\n/**\n * Gathers rich environment context for the agent's system prompt.\n * Includes working directory, platform, git status, file tree, and custom rules (AGENTS.md, etc.).\n */\nexport async function getEnvironmentContext(\n\toptions: EnvironmentOptions = {},\n): Promise<EnvironmentContext> {\n\tconst {\n\t\tcwd = process.cwd(),\n\t\tincludeFileTree = true,\n\t\tfileTreeLimit = 200,\n\t\tincludeCustomRules = true,\n\t\tcustomRuleFiles = [],\n\t} = options\n\n\tconst isGitRepo = detectGitRepo(cwd)\n\n\tconst [fileTree, customRules] = await Promise.all([\n\t\tincludeFileTree ? generateFileTree(cwd, fileTreeLimit) : undefined,\n\t\tincludeCustomRules ? loadCustomRules(cwd, customRuleFiles) : undefined,\n\t])\n\n\treturn {\n\t\tworkingDirectory: cwd,\n\t\tplatform: process.platform,\n\t\tdate: new Date().toDateString(),\n\t\tisGitRepo,\n\t\tfileTree,\n\t\tcustomRules,\n\t}\n}\n"
		}
	]
}
