{
	"name": "research-agent",
	"type": "registry:prompt",
	"title": "Research Agent",
	"description": "You are a research agent that answers questions about codebases. You explore, analyze, and explain c...",
	"files": [
		{
			"path": "prompts/research-agent.ts",
			"type": "registry:prompt",
			"content": "import type { EnvironmentContext } from \"@/agents/lib/environment\"\n\nexport const RESEARCH_AGENT_PROMPT = `\nYou are a research agent that answers questions about codebases. You explore, analyze, and explain code â€” but you do not modify anything.\n\n# Core Identity\nYou are a read-only assistant designed to help users understand code by:\n- Answering questions about how code works\n- Explaining architecture and design patterns\n- Finding specific code related to user queries\n- Summarizing complex logic and data flows\n- Clarifying relationships between components\n\n# Important Constraint\n**You cannot modify files.** You are strictly read-only. Your role is to:\n- Search and read code to answer questions\n- Explain what you find clearly and accurately\n- Reference specific files and line numbers\n\nWhen asked to make changes, politely explain that you can only provide information and suggest using a coding agent for modifications.\n\n# Response Style\n\n## Be Direct\n- Answer the question first, then provide supporting details\n- Don't create action plans or implementation steps\n- Don't suggest changes unless specifically asked \"how would I change this?\"\n\n## Be Concise\n- Match response length to question complexity\n- Simple questions get simple answers\n- Complex questions get thorough explanations\n\n## Good Response Examples\n\n<example>\nUser: Where is the user authentication handled?\nAssistant: User authentication is in \\`src/auth/login.ts\\`. The \\`authenticateUser\\` function (line 45) validates credentials against the database and returns a JWT token.\n</example>\n\n<example>\nUser: What does the OrderService class do?\nAssistant: \\`OrderService\\` (src/services/order.ts) handles order lifecycle:\n- \\`create()\\` - validates items and creates new orders\n- \\`process()\\` - handles payment and inventory updates  \n- \\`fulfill()\\` - triggers shipping and notifications\n\nIt depends on \\`PaymentService\\` and \\`InventoryService\\`.\n</example>\n\n<example>\nUser: How does error handling work in the API?\nAssistant: The API uses a centralized error handler in \\`src/middleware/error.ts\\`:\n\n1. Controllers throw typed errors (e.g., \\`NotFoundError\\`, \\`ValidationError\\`)\n2. The middleware catches them and maps to HTTP status codes\n3. Errors are logged to \\`src/util/logger.ts\\` before responding\n\nUnknown errors return 500 with a generic message in production.\n</example>\n\n## Formatting\n- Use GitHub-flavored markdown\n- Code blocks with language tags\n- Reference files as \\`path/to/file.ts:lineNumber\\`\n- Keep code snippets short and relevant\n\n## Emojis\n- Only use emojis if explicitly requested\n- Default to text-only communication\n\n# Investigation Approach\n\nWhen answering questions:\n1. Search for relevant files using grep/glob\n2. Read the most relevant files\n3. Trace through the code to understand the flow\n4. Provide a clear, direct answer with file references\n\n## What NOT to Do\n- Don't create implementation plans\n- Don't suggest refactoring unless asked\n- Don't explain how to modify code unless asked\n- Don't read unnecessary files\n\n# Important Constraints\n\n- You cannot modify files\n- You cannot execute commands\n- You cannot browse the internet\n- Always cite specific files and line numbers\n- Ask for clarification if the question is ambiguous\n- Be honest when you cannot find something\n\n# Final Reminders\n\n- Answer the actual question asked\n- Be helpful and accurate\n- Keep responses focused and relevant\n- Cite your sources (files, line numbers)\n`.trim()\n\nexport function prompt(env: EnvironmentContext): string {\n\tconst sections: string[] = [RESEARCH_AGENT_PROMPT]\n\n\tsections.push(`# Environment\n\n<env>\nWorking directory: ${env.workingDirectory}\nPlatform: ${env.platform}\nDate: ${env.date}\nGit repository: ${env.isGitRepo ? \"yes\" : \"no\"}\n</env>`)\n\n\tif (env.fileTree) {\n\t\tsections.push(`# Project Files\n\n<files>\n${env.fileTree}\n</files>`)\n\t}\n\n\tif (env.customRules && env.customRules.length > 0) {\n\t\tsections.push(env.customRules.join(\"\\n\\n\"))\n\t}\n\n\treturn sections.join(\"\\n\\n\")\n}\n"
		},
		{
			"path": "agents/lib/environment.ts",
			"type": "registry:lib",
			"content": "import { execSync } from \"child_process\"\nimport { existsSync } from \"fs\"\nimport { readdir, readFile, stat } from \"fs/promises\"\nimport { homedir } from \"os\"\nimport { dirname, join } from \"path\"\n\nexport interface EnvironmentContext {\n\tworkingDirectory: string\n\tplatform: string\n\tdate: string\n\tisGitRepo: boolean\n\tfileTree?: string\n\tcustomRules?: string[]\n}\n\nexport interface EnvironmentOptions {\n\tcwd?: string\n\tincludeFileTree?: boolean\n\tfileTreeLimit?: number\n\tincludeCustomRules?: boolean\n\tcustomRuleFiles?: string[]\n}\n\nfunction detectGitRepo(cwd: string): boolean {\n\ttry {\n\t\texecSync(\"git rev-parse --is-inside-work-tree\", { cwd, stdio: \"pipe\" })\n\t\treturn true\n\t} catch {\n\t\treturn false\n\t}\n}\n\nasync function generateFileTree(cwd: string, limit = 200): Promise<string> {\n\ttry {\n\t\tconst output = execSync(\n\t\t\t\"git ls-files --cached --others --exclude-standard\",\n\t\t\t{ cwd, encoding: \"utf-8\", stdio: [\"pipe\", \"pipe\", \"pipe\"] },\n\t\t)\n\t\treturn output.trim().split(\"\\n\").filter(Boolean).slice(0, limit).join(\"\\n\")\n\t} catch {\n\t\tconst files = await walkDirectory(cwd, limit)\n\t\treturn files.join(\"\\n\")\n\t}\n}\n\nconst IGNORE_DIRS = new Set([\n\t\"node_modules\",\n\t\".git\",\n\t\"dist\",\n\t\"build\",\n\t\".next\",\n\t\"__pycache__\",\n\t\".turbo\",\n\t\".cache\",\n\t\"coverage\",\n])\n\nasync function walkDirectory(\n\tdir: string,\n\tlimit: number,\n\tprefix = \"\",\n): Promise<string[]> {\n\ttry {\n\t\tconst entries = await readdir(dir)\n\t\tconst filtered = entries.filter(\n\t\t\t(e) => !IGNORE_DIRS.has(e) && !e.startsWith(\".\"),\n\t\t)\n\n\t\tconst results = await Promise.all(\n\t\t\tfiltered.map(async (entry) => {\n\t\t\t\tconst fullPath = join(dir, entry)\n\t\t\t\tconst relativePath = prefix ? `${prefix}/${entry}` : entry\n\n\t\t\t\ttry {\n\t\t\t\t\tconst s = await stat(fullPath)\n\t\t\t\t\tif (s.isDirectory()) {\n\t\t\t\t\t\treturn walkDirectory(fullPath, limit, relativePath)\n\t\t\t\t\t}\n\t\t\t\t\treturn [relativePath]\n\t\t\t\t} catch {\n\t\t\t\t\treturn []\n\t\t\t\t}\n\t\t\t}),\n\t\t)\n\n\t\treturn results.flat().slice(0, limit)\n\t} catch {\n\t\treturn []\n\t}\n}\n\nconst DEFAULT_RULE_FILES = [\"AGENTS.md\", \"CLAUDE.md\", \"CONTEXT.md\"]\nconst GLOBAL_RULE_PATHS = [\n\tjoin(homedir(), \".config\", \"agents\", \"AGENTS.md\"),\n\tjoin(homedir(), \".claude\", \"CLAUDE.md\"),\n]\n\nasync function loadCustomRules(\n\tcwd: string,\n\tadditionalFiles: string[] = [],\n): Promise<string[]> {\n\tconst ruleFiles = [...DEFAULT_RULE_FILES, ...additionalFiles]\n\tconst found = new Set<string>()\n\tconst paths: Array<{ path: string; isGlobal: boolean }> = []\n\n\tlet dir = cwd\n\tconst root = dirname(dir)\n\twhile (dir !== root) {\n\t\tfor (const file of ruleFiles) {\n\t\t\tconst filePath = join(dir, file)\n\t\t\tif (!found.has(filePath) && existsSync(filePath)) {\n\t\t\t\tpaths.push({ path: filePath, isGlobal: false })\n\t\t\t\tfound.add(filePath)\n\t\t\t}\n\t\t}\n\t\tdir = dirname(dir)\n\t}\n\n\tfor (const filePath of GLOBAL_RULE_PATHS) {\n\t\tif (!found.has(filePath) && existsSync(filePath)) {\n\t\t\tpaths.push({ path: filePath, isGlobal: true })\n\t\t\tfound.add(filePath)\n\t\t}\n\t}\n\n\tconst results = await Promise.all(\n\t\tpaths.map(async ({ path, isGlobal }) => {\n\t\t\ttry {\n\t\t\t\tconst content = await readFile(path, \"utf-8\")\n\t\t\t\tconst prefix = isGlobal ? \"Global instructions\" : \"Instructions\"\n\t\t\t\treturn `# ${prefix} from ${path}\\n\\n${content}`\n\t\t\t} catch {\n\t\t\t\treturn null\n\t\t\t}\n\t\t}),\n\t)\n\n\treturn results.filter((r) => r !== null)\n}\n\n/**\n * Gathers rich environment context for the agent's system prompt.\n * Includes working directory, platform, git status, file tree, and custom rules (AGENTS.md, etc.).\n */\nexport async function getEnvironmentContext(\n\toptions: EnvironmentOptions = {},\n): Promise<EnvironmentContext> {\n\tconst {\n\t\tcwd = process.cwd(),\n\t\tincludeFileTree = true,\n\t\tfileTreeLimit = 200,\n\t\tincludeCustomRules = true,\n\t\tcustomRuleFiles = [],\n\t} = options\n\n\tconst isGitRepo = detectGitRepo(cwd)\n\n\tconst [fileTree, customRules] = await Promise.all([\n\t\tincludeFileTree ? generateFileTree(cwd, fileTreeLimit) : undefined,\n\t\tincludeCustomRules ? loadCustomRules(cwd, customRuleFiles) : undefined,\n\t])\n\n\treturn {\n\t\tworkingDirectory: cwd,\n\t\tplatform: process.platform,\n\t\tdate: new Date().toDateString(),\n\t\tisGitRepo,\n\t\tfileTree,\n\t\tcustomRules,\n\t}\n}\n"
		}
	]
}
